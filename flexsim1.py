import streamlit as st
import openai
import os
import requests
import json
import uuid
import datetime
from dotenv import load_dotenv

# Carregar vari√°veis de ambiente (opcional, para seguran√ßa)
load_dotenv()

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="ChatBot OpenAI",
    page_icon="ü§ñ",
    layout="centered"
)

# Estilo CSS
st.markdown("""
<style>
.chat-message {
    padding: 1rem;
    border-radius: 10px;
    margin-bottom: 10px;
    display: flex;
    flex-direction: row;
    color: black;
    font-weight: 500;
}
.chat-message.user {
    background-color: #e6e6e6;
    border-left: 5px solid #2e72ea;
}
.chat-message.assistant {
    background-color: #f5f5f5;
    border-left: 5px solid #10a37f;
}
.chat-message .avatar {
    width: 10%;
    display: flex;
    align-items: center;
    justify-content: center;
}
.chat-message .content {
    width: 90%;
}
.chat-message .avatar img {
    max-width: 40px;
    max-height: 40px;
    border-radius: 50%;
    object-fit: cover;
}
.content p {
    font-size: 16px;
    line-height: 1.5;
    color: #000000;
}
</style>
""", unsafe_allow_html=True)

# Fun√ß√£o para obter a API key
def get_openai_api_key():
    # Tenta obter a API key do ambiente
    api_key = os.getenv("OPENAI_API_KEY")
    
    # Se n√£o encontrar no ambiente, pede ao usu√°rio
    if not api_key:
        api_key = st.sidebar.text_input("OpenAI API Key", type="password")
        if not api_key:
            st.sidebar.warning("Por favor, insira sua API key para continuar.")
    
    return api_key

# Fun√ß√£o para enviar dados para o webhook do Make
def send_to_webhook(conversation_data):
    try:
        response = requests.post(
            WEBHOOK_URL,
            json=conversation_data,
            headers={"Content-Type": "application/json"}
        )
        
        if response.status_code == 200:
            st.sidebar.success("Dados enviados com sucesso!", icon="‚úÖ")
            return True
        else:
            st.sidebar.error(f"Erro ao enviar dados: {response.status_code}")
            return False
    except Exception as e:
        st.sidebar.error(f"Erro na comunica√ß√£o com webhook: {str(e)}")
        return False

# Inicializa√ß√£o da sess√£o
if "messages" not in st.session_state:
    st.session_state.messages = []

if "assistant_id" not in st.session_state:
    st.session_state.assistant_id = ""
    
if "conversation_id" not in st.session_state:
    st.session_state.conversation_id = str(uuid.uuid4())
    
if "user_info" not in st.session_state:
    st.session_state.user_info = {
        "name": "",
        "email": "",
        "phone": ""
    }

# URL do webhook Make
WEBHOOK_URL = "https://hook.us2.make.com/iu7sc1vc4254f29zop2f6j8e24a4dnj4"

# Sidebar para configura√ß√µes
st.sidebar.title("Configura√ß√µes")

# Campo para o ID do assistente
assistant_id = st.sidebar.text_input("ID do Assistente OpenAI", value=st.session_state.assistant_id)
if assistant_id != st.session_state.assistant_id:
    st.session_state.assistant_id = assistant_id
    
# Informa√ß√µes do usu√°rio para leads
st.sidebar.title("Suas Informa√ß√µes")
st.sidebar.markdown("Preencha para salvar seus dados de contato")

user_name = st.sidebar.text_input("Nome", value=st.session_state.user_info["name"])
user_email = st.sidebar.text_input("Email", value=st.session_state.user_info["email"])
user_phone = st.sidebar.text_input("Telefone", value=st.session_state.user_info["phone"])

# Atualiza as informa√ß√µes do usu√°rio
if (user_name != st.session_state.user_info["name"] or 
    user_email != st.session_state.user_info["email"] or 
    user_phone != st.session_state.user_info["phone"]):
    
    st.session_state.user_info["name"] = user_name
    st.session_state.user_info["email"] = user_email
    st.session_state.user_info["phone"] = user_phone

# T√≠tulo principal
st.title("ChatBot com OpenAI Assistant")

# Obten√ß√£o da API key
api_key = get_openai_api_key()

# Fun√ß√£o para exibir mensagens
def display_messages():
    for message in st.session_state.messages:
        with st.container():
            role = message["role"]
            content = message["content"]
            
            if role == "user":
                avatar = "üë§"
                bg_color = "user"
                name = "Voc√™"
            else:
                avatar = "ü§ñ"
                bg_color = "assistant"
                name = "Assistente"
                
            st.markdown(f"""
            <div class="chat-message {bg_color}">
                <div class="avatar">
                    <p>{avatar}</p>
                </div>
                <div class="content">
                    <strong>{name}</strong>
                    <p>{content}</p>
                </div>
            </div>
            """, unsafe_allow_html=True)

# Exibir hist√≥rico de mensagens
display_messages()

# Campo de entrada para nova mensagem
if prompt := st.chat_input("Digite sua mensagem aqui..."):
    # Verificar se todas as configura√ß√µes necess√°rias est√£o dispon√≠veis
    if not api_key:
        st.error("Por favor, insira sua API key na barra lateral.")
    elif not assistant_id:
        st.error("Por favor, insira o ID do seu assistente na barra lateral.")
    else:
        # Adicionar mensagem do usu√°rio ao hist√≥rico
        st.session_state.messages.append({"role": "user", "content": prompt})
        
        # Reexibir as mensagens com a nova do usu√°rio
        with st.spinner("Pensando..."):
            try:
                # Configurar cliente da OpenAI
                client = openai.OpenAI(api_key=api_key)
                
                # Criar um thread
                thread = client.beta.threads.create()
                
                # Adicionar a mensagem do usu√°rio ao thread
                client.beta.threads.messages.create(
                    thread_id=thread.id,
                    role="user",
                    content=prompt
                )
                
                # Executar o assistente com o thread
                run = client.beta.threads.runs.create(
                    thread_id=thread.id,
                    assistant_id=assistant_id
                )
                
                # Esperar a conclus√£o da execu√ß√£o
                while run.status in ["queued", "in_progress"]:
                    run = client.beta.threads.runs.retrieve(
                        thread_id=thread.id,
                        run_id=run.id
                    )
                
                # Recuperar as mensagens do thread
                messages = client.beta.threads.messages.list(
                    thread_id=thread.id
                )
                
                # Obter a resposta mais recente do assistente
                assistant_message = None
                for message in messages.data:
                    if message.role == "assistant":
                        assistant_message = message
                        break
                
                if assistant_message:
                    content = assistant_message.content[0].text.value
                    st.session_state.messages.append({"role": "assistant", "content": content})
                    
                    # Preparar dados para enviar ao webhook
                    if st.session_state.user_info["email"]:  # S√≥ envia se tiver pelo menos o email
                        conversation_data = {
                            "conversation_id": st.session_state.conversation_id,
                            "timestamp": datetime.datetime.now().isoformat(),
                            "user_info": st.session_state.user_info,
                            "last_user_message": prompt,
                            "last_assistant_response": content,
                            "conversation_history": st.session_state.messages
                        }
                        
                        # Enviar dados ao webhook de forma ass√≠ncrona
                        send_to_webhook(conversation_data)
                    
                    # Reexibir as mensagens com a resposta
                    display_messages()
                else:
                    st.error("N√£o foi poss√≠vel obter uma resposta do assistente.")
                    
            except Exception as e:
                st.error(f"Erro ao comunicar com a API da OpenAI: {str(e)}")

# Bot√£o para limpar o hist√≥rico
col1, col2 = st.columns(2)

with col1:
    if st.button("Limpar Conversa"):
        st.session_state.messages = []
        st.session_state.conversation_id = str(uuid.uuid4())  # Gera novo ID de conversa
        st.experimental_rerun()

with col2:
    if st.button("Salvar Conversa") and st.session_state.user_info["email"]:
        # Preparar dados para envio
        conversation_data = {
            "conversation_id": st.session_state.conversation_id,
            "timestamp": datetime.datetime.now().isoformat(),
            "user_info": st.session_state.user_info,
            "conversation_history": st.session_state.messages,
            "action": "manual_save"
        }
        
        # Enviar dados ao webhook
        if send_to_webhook(conversation_data):
            st.success("Conversa salva com sucesso!")
        else:
            st.error("Erro ao salvar conversa.")

# Informa√ß√µes adicionais
st.sidebar.markdown("---")
st.sidebar.markdown("""
### Como usar:
1. Insira sua API key da OpenAI
2. Insira o ID do seu assistente
3. Preencha suas informa√ß√µes de contato para salvar suas conversas
4. Converse com o chatbot!

Para criar um assistente, visite o [OpenAI Playground](https://platform.openai.com/playground).
""")

# Informa√ß√µes sobre o webhook
st.sidebar.markdown("---")
st.sidebar.markdown("""
### Integra√ß√£o com Make (Webhook)
As conversas s√£o salvas automaticamente quando:
- Voc√™ fornece pelo menos seu email
- O assistente envia uma resposta
- Voc√™ clica no bot√£o "Salvar Conversa"

Os dados s√£o enviados para o Google Sheets atrav√©s do Make.
""")
